
<%
show_hide_class = VIEWS_SCRIPTING ? 'show_hide' : 'only_show'
# assume already in Estimate form tag
e_total = BIG_DECIMAL_ZERO
e_totals = Hash.new
ea_ct_break = Hash.new	# initial values at component type break (for use in I scope calculations)
ea_break = Hash.new	# initial values at assembly break (for use in A scope calculations)
work_totals = Hash.new # working totals used for scope in calculations
is_in_dollars = Hash.new # is component type in dollars (note has_hours is is initially not, until hourly calculation is done on it)
@component_types_list.each do |ct|
	is_in_dollars[ct.id] =  (ct.has_hours) ? false : true
end

@assemblies.each do |ass|
	ea_break = e_totals.dup
	ea_ct_break = e_totals.dup
	ea_total = BIG_DECIMAL_ZERO
	ea_totals = Hash.new
	ea_ct_total = BIG_DECIMAL_ZERO
	ea_ct_totals = Hash.new
	ea_ct_subtotals = Hash.new
	ea_ct_subtotal_holds = Hash.new
	ea_ct_last_id = 0
	ea_ct_last_name = ''
	
	ea = (@estimate_assemblies[ass.id]) ? true : false	# is Assembly for this Estimate selected/checked
	ea_checked = ea || (ass.required && !ass.deactivated)	# make sure required assemblies are also selected/checked
	ea_active = ea_checked || !ass.deactivated		# all active Assemblies are those selected in Estimate already, or those not deactivated - note deactivated assemblies show if already in estimate
 	ea_show = (VIEWS_SCRIPTING) ? ea_active : true 	# always show all active assemblies if javascript is disabled
	show_totals_grid = false
	if ea_active && (view_mode == 'edit' || ea_checked)  # only show deactived assemblies if in estimate already
		ass_deact = (ass.deactivated) ? ' * ' : ''
%>
<div id="assembly_<%= ass.id %>" class="assembly <%= show_hide_class %><%= (ea_show) ? '' : ' deselected' %>"><h3><%= ass_deact + ass.description + ass_deact %></h3>
	<div class="show_hide_assembly">
<% 
		# break detectors
		last_subtotal_group = ''
		ea_ct_last_id = 0
		ea_ct_last_name = ''
		# loop through the Component Types and Components that are defined for this Assembly
		# Sort Order: 'component_types.sort_order, assembly_components.required DESC, components.description' (see AssemblyComponent.for_assembly)
		AssemblyComponent.for_assembly(ass.id).each do |ass_comp|
			comp = ass_comp.component
			est_comp = EstimateComponent.for_estimate_assembly_component(@estimate.id, ass.id, ass_comp.component.id )
			Rails.logger.debug("VVVV Estimate Component = #{est_comp.inspect.to_s}")
			# calculations
			if !est_comp.nil?
				# comp = est_comp.component
				est_comp_value = est_comp.value_or_default
			elsif !ass_comp.component.default.nil?
				est_comp_value = ass_comp.component.default.value
			else
				est_comp_value = BIG_DECIMAL_ZERO
			end
			est_comp_value_str = est_comp_value.bd_to_s(2)
			est_comp_total = est_comp_value # component total is component value if no calculations (not show_totals_grid)
			# don't show deactivated component
			comp_active = (comp.nil? || comp.deactivated || comp.component_type.nil? || comp.component_type.deactivated) ? false : true
			if comp_active
				# break by Subtotal ( and Component Type)
				if (ea_ct_last_id != ass_comp.component.component_type_id || last_subtotal_group != ass_comp.component.subtotal_group)
					if show_totals_grid
						concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => 'Sub-total '+last_subtotal_group.to_s+' ( S )' , :total_values =>  ea_ct_subtotals, :total_id => "subtotal_#{ass.id.to_s}_#{ea_ct_last_id.to_s}_#{last_subtotal_group}", :in_totals_grid => show_totals_grid }
					end
				end
				# break by Component Type
				if ea_ct_last_id != ass_comp.component.component_type_id
					if ea_ct_last_id != 0
						# don't print component headers, unless there are components to be processed
						if show_totals_grid
							concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => 'Sub-total '+last_subtotal_group.to_s+' ( S )' , :total_values =>  ea_ct_subtotals, :total_id => "subtotal_#{ass.id.to_s}_#{ea_ct_last_id.to_s}_#{last_subtotal_group}", :in_totals_grid => show_totals_grid }
							concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => ea_ct_last_name+' Grid Totals', :total_values => ea_ct_totals, :total_id => "component_type_total_#{ass.id.to_s}_#{ea_ct_last_id.to_s}", :in_totals_grid => show_totals_grid }
							concat raw "</table>" # end of Totals Grid Table
						end
						concat render :partial => 'estimate_components/list_total', :locals => { :total_label => ea_ct_last_name+' Total', :total_value =>  ea_ct_total, :total_id => "component_type_total_#{ass.id.to_s}_#{ea_ct_last_id.to_s}"}
						concat raw "</div>" # end of Component Type Div
					end # if ea_ct_last_id != 0
					concat render :partial => 'estimate_components/list_totals_head', :locals => { :assembly_component => ass_comp }
					show_totals_grid = ass_comp.component.component_type.has_totals
					if show_totals_grid
						concat raw '<div>'
						# print initial values 
						concat render :partial => 'estimate_components/list_totals_grid_head', :locals => { :assembly => ass, :assembly_component_id =>  'total', :assembly_component_title =>  "Grid Initial Values", :in_totals_grid => show_totals_grid }
						concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => 'Initial Assembly Values ( A )' , :total_values =>  ea_break, :total_id => "subtotal_#{ass.id.to_s}__#{last_subtotal_group}", :in_totals_grid => show_totals_grid }
						concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => 'Initial Component Type Values ( I / S)' , :total_values =>  e_totals, :total_id => "subtotal_#{ass.id.to_s}_#{ass_comp.component.component_type.id.to_s}_#{last_subtotal_group}", :in_totals_grid => show_totals_grid }
						concat raw "</table>" # end of Totals Grid Table
						# print grid header
						concat render :partial => 'estimate_components/list_totals_grid_head', :locals => { :assembly => ass, :assembly_component_id =>  ass_comp.component.component_type.id.to_s, :assembly_component_title =>  ass_comp.component.nil_to_s, :in_totals_grid => show_totals_grid  }
						# save off initial totals for later calculations
						ea_ct_break = e_totals.dup
					else
						concat raw '<div class="fields_20_80">'
					end # if ea_ct_last_id != ass_comp.component.component_type_id
					ea_ct_total = BIG_DECIMAL_ZERO
					ea_ct_totals = Hash.new
					ea_ct_subtotals = Hash.new
					ea_ct_subtotal_holds = Hash.new
					ea_hour = BIG_DECIMAL_ZERO	# no need to break on hash by component type !!
					ea_ct_last_id = ass_comp.component.component_type_id
					ea_ct_last_name = ass_comp.component.component_type.nil_to_s
					Rails.logger.debug("VVVV table - test show_totals_grid = #{show_totals_grid.to_s}")

				end # end break by t- if ea_ct_last_id != ass_comp.component.component_type_id
				# reset subtotals if break on subtotal or on component type
				if (ea_ct_last_id != ass_comp.component.component_type_id || last_subtotal_group != ass_comp.component.subtotal_group)
					ea_ct_subtotal_holds = ea_ct_subtotals.dup
					ea_ct_subtotals = Hash.new
					last_subtotal_group = ass_comp.component.subtotal_group
				end
			
				show_totals_grid = ass_comp.component.component_type.has_totals
				if show_totals_grid
					e_current = Hash.new
					# get scope totals for the calculation
					#	- ('A' - use Assembly break, 'I' - Grid initial totals, 'S' - use latest subtotal, 'C' - use cumulative value, 'H' - use cumulative hours)
					# Load up totals specified by the component operation for calculation
					Rails.logger.debug("VVVVSetScope = #{comp.op_scope.inspect.to_s}")
					case comp.op_scope.to_s
					when 'A' then work_totals = ea_break.dup
					when 'I' then work_totals = ea_ct_break.dup
					when 'S' then work_totals = ea_ct_subtotal_holds.dup
					else work_totals = e_totals.dup	# 'C', 'H', or undefined default to use cumulative totals
					end
				
					@component_types_list.each do |ct|
						if ct.in_totals_grid
							ct_id = ct.id
							ct_val = (work_totals[ct_id].nil?) ? BIG_DECIMAL_ZERO : work_totals[ct_id]
							# make sure only hours are operated on if op_scope = 'H', is an hourly component type that has not been converted to dollars yet
							if comp.op_scope != 'H' && is_in_dollars[ct_id]
								case comp.op_operand
								when '+' then new_val = ct_val + est_comp_value
								when '-' then new_val = ct_val - est_comp_value
								when '*' then new_val = ct_val * est_comp_value
								when '/' then new_val =  (est_comp_value != BIG_DECIMAL_ZERO) ? ct_val / est_comp_value : BIG_DECIMAL_ZERO
								end
							elsif comp.op_scope == 'H' && !is_in_dollars[ct_id]
								# only * is available for conversion of hours to dollars.
								case comp.op_operand
								when '*' then new_val = ct_val * est_comp_value
								end
							end # if comp.op_scope != 'H' || ct.has_hours
							if !new_val.nil?
								e_current[ct_id] = new_val
							end
						end # if ct.in_totals_grid
					end # @component_types_list.each do |ct|
					concat render :partial => 'estimate_components/list_grid_component', :locals => {:ass_comp => ass_comp, :ass => ass, :est_comp_value_str => est_comp_value_str, :editable => comp.editable, :comp_calculations => e_current, :view_mode => view_mode, :debug_inputs => work_totals, :is_in_dollars => is_in_dollars, :debug_formula => ' '+comp.op_operand+' '+est_comp_value_str }
				
				else
					ct_id = ass_comp.component.component_type.id
					e_totals[ct_id] = (e_totals[ct_id].nil?) ? est_comp_value : e_totals[ct_id] + est_comp_value
					ea_totals[ct_id] = (ea_totals[ct_id].nil?) ? est_comp_value : ea_totals[ct_id] + est_comp_value
					concat render :partial => 'estimate_components/list_component', :locals => {:ass_comp => ass_comp, :ass => ass, :est_comp_value_str => est_comp_value_str, :editable => comp.editable, :view_mode => view_mode }
				
				end # end if show_totals_grid
				last_ct_id = ct_id
				# accumulate totals
				if show_totals_grid
					est_comp_total = BIG_DECIMAL_ZERO
					@component_types_list.each do |ct|
						ct_id = ct.id
						if ct.in_totals_grid
							new_val = (e_current[ct_id].nil?) ? BIG_DECIMAL_ZERO : e_current[ct_id]
							ea_ct_subtotals[ct_id] = (ea_ct_subtotals[ct_id].nil?) ? new_val : ea_ct_subtotals[ct_id] + new_val
							ea_ct_totals[ct_id] = (ea_ct_totals[ct_id].nil?) ? new_val : ea_ct_totals[ct_id] + new_val
							ea_totals[ct_id] = (ea_totals[ct_id].nil?) ? new_val : ea_totals[ct_id] + new_val
							e_totals[ct_id] = (e_totals[ct_id].nil?) ? new_val : e_totals[ct_id] + new_val							
							if (comp.op_scope != 'H' && is_in_dollars[ct_id])
								est_comp_total += new_val
							elsif comp.op_scope == 'H' && !is_in_dollars[ct_id]
								est_comp_total += new_val
								# flag this hourly component type is now converted to dollars
								is_in_dollars[ct_id] = true
							end
						end # if ct.in_totals_grid
					end # @component_types_list.each do |ct|
				end # if show_totals_grid
				ea_ct_total += est_comp_total
				ea_total += est_comp_total
				e_total += est_comp_total
			end # if est_comp_active
	   	end # AssemblyComponent.for_assembly(ass.id).each
		# don't print totals, unless there were components processed
		if ea_ct_last_id != 0
			# don't print component headers, unless there are components to be processed
			if show_totals_grid
				concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => 'Sub-total '+last_subtotal_group.to_s+' ( S )' , :total_values =>  ea_ct_subtotals, :total_id => "subtotal_#{ass.id.to_s}_#{ea_ct_last_id.to_s}_#{last_subtotal_group}", :in_totals_grid => show_totals_grid }
				concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => ea_ct_last_name+' Grid Totals', :total_values => ea_ct_totals, :total_id => "component_type_total_#{ass.id.to_s}_#{ea_ct_last_id.to_s}", :in_totals_grid => show_totals_grid }
				concat raw "</table>" # end of Totals Grid Table
			end
			concat render :partial => 'estimate_components/list_total', :locals => { :total_label => ea_ct_last_name+' Total', :total_value =>  ea_ct_total, :total_id => "component_type_total_#{ass.id.to_s}_#{ea_ct_last_id.to_s}"}
			concat raw "</div>" # end of Component Type Div
		end # if ea_ct_last_id != 0
%>
	</div> <!-- end of div class="show_hide_assembly" -->
<%
			concat render :partial => 'estimate_components/list_totals_grid_head', :locals => { :assembly => ass, :assembly_component_id =>  'total', :assembly_component_title =>  "Component Type Totals", :in_totals_grid => false  }
			concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => "#{ass_deact} #{ass.description} #{ass_deact}", :total_values => ea_totals, :total_id => "assembly_component_type_totals_#{ass.id.to_s}", :in_totals_grid => false }
			concat raw "</table>" # end of Totals Grid Table
%>
</div> <!-- end of div id="assembly_<%= ass.id %>" -->
<%
		# concat render :partial => 'estimate_components/list_totals_grid_head', :locals => { :assembly => ass, :assembly_component_id =>  'total', :assembly_component_title =>  "Component Type Totals", :in_totals_grid => false  }
		# concat render :partial => 'estimate_components/list_totals_grid_subtotal', :locals => { :total_label => "#{ass_deact} #{ass.description} #{ass_deact}", :total_values => ea_totals, :total_id => "assembly_component_type_totals_#{ass.id.to_s}", :in_totals_grid => false }
		# concat raw "</table>" # end of Totals Grid Table
	end # ea_checked
end # if @assemblies.each
concat render :partial => 'estimate_components/list_total', :locals => { :total_label => 'Grand Total', :total_value =>  e_total, :total_id => "grand_total" }
%>

